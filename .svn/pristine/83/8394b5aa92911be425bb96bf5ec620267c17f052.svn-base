# encoding: utf-8


class Search
  #include ActionView::Helpers::SanitizeHelper
  include ActionView::Helpers

  def self.search_elements_by_type(element_type,search_text,article_id,results_per_page,page = 1)
    if I18n.locale.to_s == "gl"
      search_languages = ["gl","es"]
    else 
      search_languages = [I18n.locale.to_s]
    end
    
    #CASO DE BUSQUEDA DESAMBIAGUADA buscamos por ActiveRecord
    if search_text != nil && search_text.index("#") != nil &&  search_text.index("#") == 0      
      #Si accedemos por la URL de desambiguacion viene con article id      
      if article_id != nil
        if results_per_page == 4 #Busqueda general esta limitada a 4 resultados (aumento de velocidad)
          tags_annotations = TaggableTagAnnotation.where(:wikipedia_article_id => article_id, :taggable_type => element_type).order("weight DESC").limit(results_per_page)
          elements_results = element_type.constantize.find_all_by_id(tags_annotations.map{|annotation| annotation.taggable_id}).first(results_per_page)
        else #Busqueda en un recurso particular ya no esta limitada
          tags_annotations = TaggableTagAnnotation.where(:wikipedia_article_id => article_id, :taggable_type => element_type).order("weight DESC")
          elements_results = element_type.constantize.find_all_by_id(tags_annotations.map{|annotation| annotation.taggable_id})
        end
        if elements_results.size > 0
           elements = Kaminari.paginate_array(elements_results).page(page).per(results_per_page)         
           #elements = Sunspot::Search::PaginatedCollection.new(elements_results,1,elements_results.size,elements_results.size)           
           num_results = elements_results.size
        else
           search = self.get_empty_sunspot_search(element_type)           
           elements = search[:results]
           num_results=search[:total]           
        end
      #Si NO accedemos por la URL de desambiguacion. Puesto a saco la # en buscador                        
      else
        search_terms = Util.to_tag(search_text)
        tag_search_terms = Tag.find_by_name(search_terms)
        if tag_search_terms != nil 
          if results_per_page == 4 #Busqueda general esta limitada a 4 resultados (aumento de velocidad)
            tags_annotations = TaggableTagAnnotation.where(:tag_id => tag_search_terms.id, :taggable_type => element_type, :type_tag => ["automatic","automatic_from_human"]).order("weight DESC").limit(results_per_page)
            elements_results = element_type.constantize.find_all_by_id(tags_annotations.map{|annotation| annotation.taggable_id}).first(results_per_page)
          else #Busqueda en un recurso particular ya no esta limitada
            tags_annotations = TaggableTagAnnotation.where(:tag_id => tag_search_terms.id, :taggable_type => element_type, :type_tag => ["automatic","automatic_from_human"]).order("weight DESC")
            elements_results = element_type.constantize.find_all_by_id(tags_annotations.map{|annotation| annotation.taggable_id})
          end
          if elements_results.size > 0
            elements = Kaminari.paginate_array(elements_results).page(page).per(results_per_page)         
            #elements = Sunspot::Search::PaginatedCollection.new(elements_results,1,elements_results.size,elements_results.size)
            num_results = elements_results.size
          else
            search = self.get_empty_sunspot_search(element_type)           
            elements = search[:results]
            num_results=search[:total] 
          end
        else
          search = self.get_empty_sunspot_search(element_type)           
          elements = search[:results]
          num_results=search[:total]         
        end                
      end                      
      return :results => elements, :total => num_results                
        
    #CASO DE BUSQUEDA SIN DESAMBIGUAR (Como no pudimos poner bien el tokenizador lo separamos, si no con esto ya valdria)
    else 
      search_terms = search_text 
      search = element_type.constantize.search do |query|
        query.fulltext search_terms do
          boost_fields :hashtags_100 => 10.0
          boost_fields :hashtags_95 => 9.5
          boost_fields :hashtags_90 => 9
          boost_fields :hashtags_85 => 8.5
          boost_fields :hashtags_80 => 8.0
          boost_fields :hashtags_75 => 7.5
          boost_fields :hashtags_70 => 7.0
          boost_fields :hashtags_65 => 6.5
          boost_fields :hashtags_60 => 6.0
          boost_fields :hashtags_55 => 5.5
          boost_fields :hashtags_50 => 5.0
          
          boost_fields :tags => 4.0          
          #phrase_fields :tags => 10.0 
          #query.keywords search_terms, :fields => [:categories, :tags, :name] {minimum_match 1}       
        end        
        query.with(:translations, search_languages)  
        query.paginate :page => page, :per_page => results_per_page 
      end
      elements = search.results
      num_results = search.total       
      return :results => elements, :total => num_results      
    end
   
  end
  
  
  
  def self.disambiguation(search_text)
    disambiguation = Array.new
    if search_text != nil && search_text.index("#") == nil 
      wiki = Wikipediator.new
      begin 
        disamb_results = wiki.search(search_text)
        disamb_results.each do |alternative_search|
          title = alternative_search['title']
          definition = wiki.getDefinition(title)
          id = alternative_search['id']
          disambiguation << [title, definition, id] #[title, definition]
        end      
      rescue Exception => e
        puts "Exception in disambiguation"
        puts e.backtrace.inspect
        puts e.message 
      end
    end
    return disambiguation
  end
  
  
  
  def self.get_empty_sunspot_search(element_type)
    search = element_type.constantize.search do 
      fulltext "cllldsojfndjdujdsksooeinsujhdff"                
      paginate :page => 1, :per_page => 10 
    end
    elements = search.results
    num_results = search.total  
    return :results => elements, :total => num_results   
  end
  
  
  
  def disambigued_term_info(search_text)    
    term_info = Hash.new 
     
    if search_text != nil && search_text.index("#") == 0
      #Obtenemos La Definicion del wikipediator (Esto igual lo podiamos sacar ya de la wikipedia para hacer una conexion menos a un servicio)          
      w = Wikipediator.new
      definition = w.getDefinition(Util.to_tag(search_text))
      term_info[:title] = Util.to_tag(search_text)            
      term_info[:definition] = definition
      
      #Obtenemos la infobox de la Wikiepdia
      url_wiki = "http://en.wikipedia.org/wiki/" + search_text[1,search_text.size]
      begin
        page = Nokogiri::HTML(open(url_wiki))
        properties = Array.new
        infobox = page.css("table.infobox")[0]
        infobox.css("tr").each_with_index do |line,index| 
                             
          line_title = line.css("th")[0]
          article_image = false
          if line_title != nil
            line_title = strip_tags line_title.text.gsub("\n","")
          elsif line_title == nil && term_info[:image] == nil && index < 3
            begin                      
              line_title = "http:" + line.css("td")[0].css('img')[0]['src']
              article_image = true
            rescue
              puts "ERROR Obteniendo foto de infobox"
            end
          end     
                 
          line_content = line.css("td")[0]          
          if line_content != nil && line_title != nil && line_title != "Signature"
            line_content.search('sup').remove # Eliminamos los [1],[2], etc 
            line_content.search('br').each do |n|
              n.replace(", ")
            end
            
            #Colocamos espacios en blanco en las lista li                       
            line_content.search('ul').each do |ul|
              li_size = ul.search('li').size
              ul.search('li').each_with_index do |li,index_li|    
                # Esto es por si hay listas dentro de listas            
                li.search('ul').each do |sub_ul|
                  sub_li_size = sub_ul.search('li').size
                  sub_ul.search('li').each_with_index do |sub_li,index_sub_li|                   
                    if (index_sub_li+1) == sub_li_size
                      sub_li.replace("#{ sub_li.to_html.strip }")
                    else
                      sub_li.replace("#{ sub_li.to_html.strip }, ")
                    end                     
                  end
                  sub_ul.replace(sub_ul.to_html)
                end
                if (index_li+1) == li_size
                  li.replace("#{ li.to_html.strip }")
                else
                  li.replace("#{ li.to_html.strip }, ")
                end                
              end
              ul.replace(ul.to_html)
            end
            
            #Esto es para cuando un link no tiene pagia en wikipedia debido a que no se escribio aun pero tiene link
            line_content.css("a.new").each do |no_link_article|
              no_link_article.attributes['href'].remove              
              no_link_article.name = "span"              
            end
            #Eliminamos tags y y nos quedamos con el contenido
            #strip_tags line_content.text.gsub("\n","").gsub(",,",",")
            #line_content = line_content.gsub("\/wiki\/","\/search_results\/#")            
            line_content =  sanitize line_content.to_html.gsub("\n","").gsub(",,",","), tags: %w(a)
          else
            line_content = nil
          end
          if article_image == true
            term_info[:image] = line_title
          elsif line_title != nil && line_content != nil && line_title != "" && line_content != ""
            properties << {:name => line_title, :content => line_content}           
          end
        end
        term_info[:info] = properties
        return term_info
      rescue Exception => e
        puts "Exception in desambigued_term_info"
        puts e.backtrace.inspect
        puts e.message
        term_info[:info] = nil
        return term_info                
      end
    end  
  end
  
end